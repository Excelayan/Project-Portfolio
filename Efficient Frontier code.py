# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cx2L51Qp6nRJX3qkKBQOfWSI3W3EnQiq
"""

pip install yfinance matplotlib PyPortfolioOpt

import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime
import matplotlib.pyplot as plt
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models, expected_returns

# Define the list of assets and the date range
assets = ['AAPL', 'MSFT', 'GOOG', 'AMZN']
stockStartDate = '2019-05-01'
today = '2024-05-01'

# Download daily data using yfinance
df = yf.download(assets, start=stockStartDate, end=today)['Close']

# Resample to monthly frequency
df_monthly = df.resample('M').last()

# Print the DataFrame to check the results
print(df_monthly.head())

# Visually show the stock portfolio
title = 'Portfolio Close Price History'
# Get the stocks
my_stocks = df_monthly
# Create and plot the graph
plt.figure(figsize=(10, 6))
for c in my_stocks.columns.values:
    plt.plot(my_stocks[c], label=c)
plt.title(title)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)
plt.legend(my_stocks.columns.values, loc='upper left')
plt.show()

# Calculate monthly returns
returns = df_monthly.pct_change().dropna()
print(returns.head())

# Create and show the annualized covariance matrix
cov_matrix_annual = returns.cov() * 12  # 12 months in a year
print(cov_matrix_annual)

# Define initial weights for the portfolio (equal allocation for simplicity)
weights = np.array([0.25, 0.25, 0.25, 0.25])

# Calculate portfolio variance
port_variance = np.dot(weights.T, np.dot(cov_matrix_annual, weights))
print("Portfolio Variance:", port_variance)

# Calculate portfolio volatility
port_volatility = np.sqrt(port_variance)
print("Portfolio Volatility:", port_volatility)

# Calculate portfolio annual return
portfolio_simple_annual_return = np.sum(returns.mean() * weights) * 12
print("Portfolio Annual Return:", portfolio_simple_annual_return)

# Print the portfolio performance metrics
percent_var = str(round(port_variance, 4) * 100) + '%'
percent_vola = str(round(port_volatility, 4) * 100) + '%'
percent_ret = str(round(portfolio_simple_annual_return, 4) * 100) + '%'
print('Expected annual return: ' + percent_ret)
print('Annual volatility/ risk: ' + percent_vola)
print('Annual variance: ' + percent_var)

# Calculate the expected returns and the annualized sample covariance matrix of asset returns
mu = expected_returns.mean_historical_return(df_monthly, frequency=12)
S = risk_models.sample_cov(df_monthly, frequency=12)

# Define the risk range (e.g., annual volatility between 22% and 23%)
risk_min = 0.22
risk_max = 0.26

# Set a risk-free rate of 4.502% (0.04502 annual risk-free rate)
risk_free_rate = 0.04502

# Optimize for maximum Sharpe ratio
ef = EfficientFrontier(mu, S)
weights = ef.max_sharpe(risk_free_rate=risk_free_rate)
cleaned_weights = ef.clean_weights()
print("Optimized Weights:", cleaned_weights)

# Calculate portfolio performance metrics with the specified risk-free rate
expected_annual_return, annual_volatility, sharpe_ratio = ef.portfolio_performance(risk_free_rate=risk_free_rate, verbose=True)

# Check if the portfolio's volatility falls within the risk range
port_volatility = ef.portfolio_performance(risk_free_rate=risk_free_rate)[1]

# Adjust the portfolio to meet the risk range constraints
if port_volatility < risk_min or port_volatility > risk_max:
    target_risks = np.linspace(risk_min, risk_max, 100)
    best_sharpe = -np.inf
    best_weights = None
    for risk in target_risks:
        ef = EfficientFrontier(mu, S)
        ef.efficient_risk(risk)
        weights = ef.clean_weights()
        perf = ef.portfolio_performance(risk_free_rate=risk_free_rate)
        sharpe_ratio = perf[2]
        if sharpe_ratio > best_sharpe:
            best_sharpe = sharpe_ratio
            best_weights = weights

    cleaned_weights = best_weights
    ef.set_weights(best_weights)
    ef.portfolio_performance(risk_free_rate=risk_free_rate, verbose=True)

print("Optimized Weights within Risk Range:", cleaned_weights)

# Manually plot the Efficient Frontier with the risk range
def plot_efficient_frontier(mu, S, risk_min, risk_max, risk_free_rate):
    ef = EfficientFrontier(mu, S)
    max_return = ef._max_return()
    target_returns = np.linspace(mu.min(), max_return, 100)
    target_risks = []

    for ret in target_returns:
        ef = EfficientFrontier(mu, S)
        ef.efficient_return(ret)
        risk = ef.portfolio_performance(risk_free_rate=risk_free_rate)[1]
        target_risks.append(risk)

    plt.figure(figsize=(10, 6))
    plt.plot(target_risks, target_returns, label='Efficient Frontier')
    plt.axvline(x=risk_min, color='r', linestyle='--', label='Risk Min')
    plt.axvline(x=risk_max, color='g', linestyle='--', label='Risk Max')
    plt.xlabel('Risk (Standard Deviation)')
    plt.ylabel('Return')
    plt.title('Efficient Frontier with Risk Range')
    plt.legend()
    plt.show()

# Call the function to plot the efficient frontier with risk range
plot_efficient_frontier(mu, S, risk_min, risk_max, risk_free_rate)